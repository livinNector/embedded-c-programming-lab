[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Embedded C Programming Lab Manual",
    "section": "",
    "text": "Preface\nThis book contains the help documents and the exercises for the Embedded C Programming Lab.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#ides",
    "href": "index.html#ides",
    "title": "Embedded C Programming Lab Manual",
    "section": "IDEs",
    "text": "IDEs\nThere are two groups of exercises which will be using the following IDEs.\n\nSTMCubeIDE with STM HAL - Getting Started\nArduino IDE (V2) with Stm32duino - Getting Started\n\nBasic IO, Serial Communication, External and Timer interrupts will be discussed with STMCubeIDE and Interfacing with Sensors will be done using Arduino IDE.\n\n\n\n\n\n\nNote\n\n\n\nThe exercises that are done using Arduino IDE can also be done using STMCubeIDE.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#development-board",
    "href": "index.html#development-board",
    "title": "Embedded C Programming Lab Manual",
    "section": "Development board",
    "text": "Development board\nThe exercise here are implemented using STM Nucleo-144 F767ZI development board.\n\nNucleo-144 boards User manual - UM1974\nNucleo-F767ZI MCU data brief - https://www.st.com/resource/en/data_brief/nucleo-f767zi.pdf\nSTM32F767ZI MPU datasheet - https://www.st.com/resource/en/data_brief/nucleo-f767zi.pdf",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#components",
    "href": "index.html#components",
    "title": "Embedded C Programming Lab Manual",
    "section": "Components",
    "text": "Components\n\nBuilt-in LEDs (PB0,PB7,PB14) and Pushbutton (PC13)\nBuilt-in Serial UART\nUltrasonic sensor - HC-SR04\nTemperature Sensor - MCP9808\nAccelerometer and gyroscope - MPU-6050",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "exercises.html",
    "href": "exercises.html",
    "title": "1  List of exercises",
    "section": "",
    "text": "Using STMCube IDE with STM HAL\n\nUART - Hello world\n\nTransmit - Simple UART Transmission\nLoopback\nWith Timer Interrupt(Optional)\nInterrupt based UART(Optional)\n\nGPIO - Led blink - Clock counter\n\nUsing HAL_Delay\nUsing Timer Interrupts\nUsing External(Pushbutton) Interrupts\n\n\nUsing Arduino IDE with STM32duino\n\nInterfacing with Sensors\n\nUltrasonic sensor for distance measurement - HC-SR04\nTemperature measurement using I2C - MCP9808\nAccelerometer and gyroscope - MPU-6050",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>List of exercises</span>"
    ]
  },
  {
    "objectID": "getting_started/stmcube_ide_getting_started.html",
    "href": "getting_started/stmcube_ide_getting_started.html",
    "title": "2  STMCubeIDE: Getting Started and How-Tos",
    "section": "",
    "text": "2.1 Logging in into ST-Account\nThe download of the firmware in STMCubeIDE requires you to be logged in with an MyST account in the IDE. To login, Select Help -&gt; STMCube Updates -&gt; Connection to MyST.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>STMCubeIDE: Getting Started and How-Tos</span>"
    ]
  },
  {
    "objectID": "getting_started/stmcube_ide_getting_started.html#logging-in-into-st-account",
    "href": "getting_started/stmcube_ide_getting_started.html#logging-in-into-st-account",
    "title": "2  STMCubeIDE: Getting Started and How-Tos",
    "section": "",
    "text": "Note\n\n\n\nIf you try to generate code without logging in to the MyST account in your IDE, you won’t be able to generate code as the download of the firmware files for the board requires login.\n\n\n\n\n\n\n\n\nCaution\n\n\n\nIf you see a small warning icon  in the project icon in the file explorer , it means the project is not properly generated. Check whether you have logged in properly.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>STMCubeIDE: Getting Started and How-Tos</span>"
    ]
  },
  {
    "objectID": "getting_started/stmcube_ide_getting_started.html#terminology",
    "href": "getting_started/stmcube_ide_getting_started.html#terminology",
    "title": "2  STMCubeIDE: Getting Started and How-Tos",
    "section": "2.2 Terminology",
    "text": "2.2 Terminology\n\nSTMCubeIDE - An development environment containing many tools that are required in stm32 based project development.\nSTMCubeMX - A Configuration and Initialization code generation tool used for configuration of different peripherals.\n.ioc file - A file generated by STMCubeMX, containing the configuration, when opened with STMCubeIDE will open an CubeMX window.\nWorkspace - An workspace is a parent directory(or folder) which will contain a group of projects(seperate exercises).\nProject - A subfolder within a workspace containing all the source files, libraries and .ioc file for a particular program which can be uploaded at a time in the development board.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>STMCubeIDE: Getting Started and How-Tos</span>"
    ]
  },
  {
    "objectID": "getting_started/stmcube_ide_getting_started.html#recommended-conventions-for-the-lab",
    "href": "getting_started/stmcube_ide_getting_started.html#recommended-conventions-for-the-lab",
    "title": "2  STMCubeIDE: Getting Started and How-Tos",
    "section": "2.3 Recommended Conventions for the lab",
    "text": "2.3 Recommended Conventions for the lab\n\nUse a new workspace named ‘embedded_c_lab’.\nName the projects accordingly as '{exercise_no}.{task_no}_{name of the exercise}' (Eg, 1.2_serial_loopback) so that it will be displayed in the explorer in an ordered fashion.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>STMCubeIDE: Getting Started and How-Tos</span>"
    ]
  },
  {
    "objectID": "getting_started/stmcube_ide_getting_started.html#creating-an-stm32-project",
    "href": "getting_started/stmcube_ide_getting_started.html#creating-an-stm32-project",
    "title": "2  STMCubeIDE: Getting Started and How-Tos",
    "section": "2.4 Creating an STM32 Project",
    "text": "2.4 Creating an STM32 Project\n\nOpen STMCubeIDE and create a new STM32 project. Refer this for more info.\nFrom the Target Selection dialog box select the “Board Selector” tab and in the commercial part number, type “Nucleo-F767ZI”, select the board and click next.\nGo with the default settings and finish the setup. .\nInitalize peripherals in default mode(if needed you can start blank).",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>STMCubeIDE: Getting Started and How-Tos</span>"
    ]
  },
  {
    "objectID": "getting_started/stmcube_ide_getting_started.html#generating-code-with-cubemx",
    "href": "getting_started/stmcube_ide_getting_started.html#generating-code-with-cubemx",
    "title": "2  STMCubeIDE: Getting Started and How-Tos",
    "section": "2.5 Generating code with CubeMX",
    "text": "2.5 Generating code with CubeMX\nThe CubeMX window can be opened by opening the {project_name}.ioc file inside the project folder. When the changes in the .ioc file is saved it will prompt you to generate code.\n\n\n\n\n\n\nTip\n\n\n\nYou can also generate code after configuration using Project-&gt;Generate Code from the menu bar.\n\n\nAfter generating code using CubeMX you will find some directories in your project folder.\nFor this lab we will be only editing the /{project_name}/Core/Src/main.c, which has the main program that need to be executed.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>STMCubeIDE: Getting Started and How-Tos</span>"
    ]
  },
  {
    "objectID": "getting_started/stmcube_ide_getting_started.html#contents-of-main.c-generated-by-cubemx",
    "href": "getting_started/stmcube_ide_getting_started.html#contents-of-main.c-generated-by-cubemx",
    "title": "2  STMCubeIDE: Getting Started and How-Tos",
    "section": "2.6 Contents of main.c generated by CubeMX",
    "text": "2.6 Contents of main.c generated by CubeMX\nIn the main.c file you can find the code generated by CubeMX and different sections for user code identified by comments of the below format.\n/* USER CODE BEGIN &lt;section_name&gt; */\n\n/* USER CODE END &lt;section_name&gt; */\nThese lines from main.c won’t be changed even if the configuration from the CubeMX are changed.\nFor this lab we will be writing codes in the below user slots.\n\n\n\n\n\n\n\n\nSection Name\nPostion\nUsecase\n\n\n\n\nIncludesPTDPDPM\nafter default includes\nFor user includes, typedefs, defines, and macros respectively.\n\n\nPV\nbefore main function\nFor global variables.\n\n\nPFP\nbefore main function\nFor user-defined function prototypes.\n\n\n0\nbefore main function\nFor user-defined functions\n\n\n1\ninside main function before hal init\nHAL functions cannot be used here. Can be used to initialize local variables used in the main function.\n\n\n2\ninside main function after hal init\nHAL functions can be used here. Can be used for running HAL functions once during start.\n\n\nWHILE\ninside main inside while loop\nThe code for the main loop\n\n\n3\ninside main after the while loop\nThis can be used for programs that breaks the while loop after some time.\n\n\n4\nafter the main function after basic configs\nThis can be used for callbacks and ISR.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe Code Examples given for CubeMX generated code will have two views in this manual which can be toggled.\n\nSingle View - This view will have the overall structure of the code with only the user code slots surrounded by the slot comments as described above and not the complete code.\nParts View - This view will have the individual user sections as seperate code blocks, making it easier for copy pasting into the IDE.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>STMCubeIDE: Getting Started and How-Tos</span>"
    ]
  },
  {
    "objectID": "getting_started/stmcube_ide_getting_started.html#common-problems-during-setup-and-solution",
    "href": "getting_started/stmcube_ide_getting_started.html#common-problems-during-setup-and-solution",
    "title": "2  STMCubeIDE: Getting Started and How-Tos",
    "section": "2.7 Common problems during setup and solution",
    "text": "2.7 Common problems during setup and solution\n\n\nCannot open workspace, workspace is currently in use\n\nKill the CubeIDE process and delete the .lock file in the .metadata directory in your eclipse workspace directory. Precaution - If you delete the .metadata folder all preference will be deleted.\n\n\n\narm-none-eabi-gdb –version /lib/libncurses.so.5 not found\n\n\nIn ubuntu, install libncurses5 using sudo apt-get install libncurses5.\nIn Arch or Manjaro, install compatibility libs using pamac install ncurses5-compat-libs.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>STMCubeIDE: Getting Started and How-Tos</span>"
    ]
  },
  {
    "objectID": "exercises/1_uart.html",
    "href": "exercises/1_uart.html",
    "title": "3  UART Serial Communication using STM32 HAL",
    "section": "",
    "text": "3.1 Objective:\nBy the end of this exercise, students will:",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>UART Serial Communication using STM32 HAL</span>"
    ]
  },
  {
    "objectID": "exercises/1_uart.html#objective",
    "href": "exercises/1_uart.html#objective",
    "title": "3  UART Serial Communication using STM32 HAL",
    "section": "",
    "text": "Understand the basics of UART communication.\nConfigure UART using STM32 HAL in CubeIDE using CubeMX for the STM Nucleo-144 F767ZI board.\nTransmit and receive data over USART3(It will be set to Asynchronous mode).\nImplement simple communication between the STM32 microcontroller and a serial terminal on a PC.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>UART Serial Communication using STM32 HAL</span>"
    ]
  },
  {
    "objectID": "exercises/1_uart.html#materials",
    "href": "exercises/1_uart.html#materials",
    "title": "3  UART Serial Communication using STM32 HAL",
    "section": "3.2 Materials:",
    "text": "3.2 Materials:\n\nSTM Nucleo-144 F767ZI development board.\nUSB to TTL Serial converter (or onboard ST-LINK USB).\nCubeIDE installed on the PC.\nSerial terminal software (e.g., PuTTY, Tera Term, or the serial monitor in CubeIDE).",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>UART Serial Communication using STM32 HAL</span>"
    ]
  },
  {
    "objectID": "exercises/1_uart.html#viewing-uart-output",
    "href": "exercises/1_uart.html#viewing-uart-output",
    "title": "3  UART Serial Communication using STM32 HAL",
    "section": "3.3 Viewing UART Output",
    "text": "3.3 Viewing UART Output\nThe output from the UART can be seen in two ways.\n\nUsing a Command Shell Console \nUsing Terminal Extension\nTo install the terminal extensions in CubeIDE follow the steps here.\n\n\n\n\n\n\nCaution\n\n\n\nCaution: While following the aboe tutorial to install built-in terminal, in the “Work with” text box(a box that has the text “type or select site”), select “Eclipse Repository” and DO NOT select “all available sites” this may cause the IDE to stop responding.\n\n\n\n\nIdentifying the port\nThe Serial port name will be usually like COM 3 or COM 9 in windows and /dev/ttyACM0 in linux.\nIn Windows, press Win+x and then m to open the device manager (or search from the start button). In the ports pheripheral you can find the port used by STM32.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>UART Serial Communication using STM32 HAL</span>"
    ]
  },
  {
    "objectID": "exercises/1_uart.html#cubemx-configuration",
    "href": "exercises/1_uart.html#cubemx-configuration",
    "title": "3  UART Serial Communication using STM32 HAL",
    "section": "3.4 CubeMX Configuration:",
    "text": "3.4 CubeMX Configuration:\n\n1. Create a New Project:\n\nLaunch CubeIDE and create a new project.\nSelect STM Nucleo-144 F767ZI board (or the the STM32F767ZI microcontroller).\n\n\n\n2. Enable USART3 Peripheral:\n\nIn the Pinout & Configuration tab, enable USART3 (can be found under connectivity category) and set mode to Asynchronous (This will be already there if you have chosen the default peripheral configurations).\nAssign the appropriate pins for TX (PD8) and RX (PD9) for USART3.\n\n\n\n3. UART Configuration:\n\nSet Baud Rate to 9600.\nConfigure 8 data bits, No parity, and 1 stop bit.\nEnable both Transmit and Receive.\n\n\n\n4. Enable NVIC Settings (Optional for USART3 Interrupts):\n\nIf using interrupts, enable USART3 global interrupt.\n\n\n\n5. TIM7 Configuration (Optional for Timer Interrupts)\n\nEnable TIM7 (can be found under timer category) (or any other available timer).\nConfigure the timer with a prescaler and period to generate an interrupt every 1 second.\nIn the Parameter Settings, set the following configuration.\n\nPrescaler - 48000-1\nCounter Mode - Up\nCounter Period - 2000-1\n\\[\\begin{align*}\\text{Interrupt Interval} &= \\frac{(\\text{Counter Period}+1)\\times(\\text{Prescaler}+1)}{\\text{Clock Source Frequency}}\\\\ &=\\frac{2000 \\times 48000}{96\\times10^6}=1 \\text{s}\\end{align*}\\]\n\nIn the NVIC Settings, enable the TIM7 global interrupt.\n\n\n\n\n\n\n\nNote\n\n\n\nWe are selecting TIM7 for timer as it is one of the basic timers. It uses the APB1 timer clock source as the clock source (Refer this block diagram and this section).\nThe frequency of the APB1 timer clock can be verified using the Clock Configuration tab.\n\n\n\n\n6. Generate Code:\n\nSave the .ioc file using CTRL + s and you will be prompted to generate code. You can make this the default choice. You can generate code manually by using Project &gt; Generate Code to create the project with the configured settings.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>UART Serial Communication using STM32 HAL</span>"
    ]
  },
  {
    "objectID": "exercises/1_uart.html#explanation-of-key-functions",
    "href": "exercises/1_uart.html#explanation-of-key-functions",
    "title": "3  UART Serial Communication using STM32 HAL",
    "section": "3.5 Explanation of Key Functions:",
    "text": "3.5 Explanation of Key Functions:\nExplanations of these functions can be found in the UM1850\n\nHAL_UART_Transmit\n\nThis function sends data through the UART peripheral.\nSyntax:\n\nHAL_UART_Transmit(&huart3, data, length, timeout);\n\nExample:\n\nuint8_t msg[] = \"Hello, UART!\";\nHAL_UART_Transmit(&huart3, msg, sizeof(msg)-1, HAL_MAX_DELAY);  // Transmit the message\nHAL_UART_Receive\n\nThis function receives data through the UART peripheral.\nSyntax:\n\nHAL_UART_Receive(&huart3, buffer, length, timeout);\n\nExample:\n\nuint8_t rxBuffer[10];\nHAL_UART_Receive(&huart3, rxBuffer, 10, HAL_MAX_DELAY);  // Receive data\nHAL_UART_Receive_IT\n\nThis function enables interrupt-based data reception.\nIt allows the microcontroller to handle data asynchronously.\nSyntax:\n\nHAL_UART_Receive_IT(&huart3, buffer, length);\nHAL_TIM_Base_Start_IT\n\nUsed to start a timer in interrupt mode, which can be useful for periodic actions like transmitting data every second.\nExample:\n\nHAL_TIM_Base_Start_IT(&htim7);  // Start timer 7 in interrupt mode\nHAL_TIM_PeriodElapsedCallback\n\nThis function is called when a timer interrupt occurs.\nIt can be used to perform tasks at specific intervals, such as sending a string over UART.\n\nHAL_UART_RxCpltCallback\n\nThis function is called when an interrupt based reception is completed.\nIt can be used to perform tasks after a certain bytes of data is recieved over UART.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>UART Serial Communication using STM32 HAL</span>"
    ]
  },
  {
    "objectID": "exercises/1_uart.html#tasks-and-sample-io-behavior",
    "href": "exercises/1_uart.html#tasks-and-sample-io-behavior",
    "title": "3  UART Serial Communication using STM32 HAL",
    "section": "3.6 Tasks and Sample IO Behavior:",
    "text": "3.6 Tasks and Sample IO Behavior:\n\nTask 1: Simple UART Communication\n\nTransmit a string (“Hello, UART!”) from the STM32 to the PC serial terminal via USART3.\n\n\nCode Example:\n\nSingleParts\n\n\nvoid main(void){\n\n  /* USER CODE BEGIN 2 */\n\n  uint8_t msg[] = \"Hello, UART!\";\n  HAL_UART_Transmit(&huart3, msg, sizeof(msg)-1, HAL_MAX_DELAY);  // Transmit the message\n\n  /* USER CODE END 2 */\n\n}\n\n\nUSER CODE BEGIN 2\nuint8_t msg[] = \"Hello, UART!\";\nHAL_UART_Transmit(&huart3, msg, sizeof(msg)-1, HAL_MAX_DELAY);  // Transmit the message\n\n\n\n\n\nSample IO:\n\nOutput: The string “Hello, UART!” appears in the serial terminal on the PC.\n\n\n\n\nTask 2: Implement a Loopback Test\n\nModify the code so that the STM32 receives data from the serial terminal and echoes it back.\n\n\nCode Example:\n\nSingleParts\n\n\nint main(void) {\n  /* USER CODE BEGIN 1 */\n  uint8_t rxBuffer[5];  // Buffer to store received data\n    // Try changing the buffer size\n  /* USER CODE END 1 */\n\n  /* USER CODE BEGIN WHILE */\n  while (1) {\n    // Receive data from the serial terminal\n    HAL_UART_Receive(&huart3, rxBuffer, sizeof(rxBuffer), HAL_MAX_DELAY);\n\n    // Echo the received data back to the terminal\n    HAL_UART_Transmit(&huart3, rxBuffer, sizeof(rxBuffer), HAL_MAX_DELAY);\n\n    /* USER CODE END WHILE */\n\n    /* USER CODE BEGIN 3 */\n  }\n  /* USER CODE END 3 */\n}\n\n\nUSER CODE BEGIN 1\nuint8_t rxBuffer[5];  // Buffer to store received data\n// Try changing the buffer size\nUSER CODE BEGIN WHILE\n// Receive data from the serial terminal\nHAL_UART_Receive(&huart3, rxBuffer, sizeof(rxBuffer), HAL_MAX_DELAY);\n\n// Echo the received data back to the terminal\nHAL_UART_Transmit(&huart3, rxBuffer, sizeof(rxBuffer), HAL_MAX_DELAY);\n\n\n\n\n\nSample IO:\n\nInput: If you type “STM32” in the serial terminal.\nOutput: “STM32” is echoed back to the terminal.\n\n\n\n\nTask 3: Send a String Every 1 Second Using Timer Interrupt\n\nUse a timer interrupt to send a string (“STM32 Timer Test n”) every 1 second.\nTIM\n\n\nCode Example:\n\nSingleParts\n\n\n/* USER CODE BEGIN PV */\nvolatile uint64_t counter = 0; // to keep track of the number of times printed\n/* USER CODE END PV */\n\nint main(void) {\n\n  /* USER CODE BEGIN 2 */\n  // Start timer in interrupt mode\n  HAL_TIM_Base_Start_IT(&htim7);\n  /* USER CODE END 2 */\n\n}\n\n/* USER CODE BEGIN 4 */\n// Timer interrupt callback function\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {\n    if (htim-&gt;Instance == TIM7) {\n        // Send message every second\n        uint8_t msg[50];\n        uint8_t n_bytes = sprintf(msg,\"STM32 Timer Test %lu \\n\\r\", counter);\n        HAL_UART_Transmit(&huart3, msg, n_bytes, HAL_MAX_DELAY);\n        counter++;\n    }\n}\n/* USER CODE END 4 */\n\n\nUSER CODE BEGIN PV\nvolatile uint64_t counter = 0; // to keep track of the number of times printed\nUSER CODE BEGIN 2\n// Start timer in interrupt mode\nHAL_TIM_Base_Start_IT(&htim7);\nUSER CODE BEGIN 4\n// Timer interrupt callback function\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {\n    if (htim-&gt;Instance == TIM7) {\n        // Send message every second\n        uint8_t msg[50];\n        uint8_t n_bytes = sprintf(msg,\"STM32 Timer Test %lu \\n\\r\", counter);\n        HAL_UART_Transmit(&huart3, msg, n_bytes, HAL_MAX_DELAY);\n        counter++;\n    }\n}\n\n\n\n\n\nSample IO:\n\nOutput: The string “STM32 Timer Test” is sent to the serial terminal every second.\n\n\n\n\nTask 4: Interrupt-Based UART Communication\n\nConfigure UART communication using interrupts to receive and echo data asynchronously.\n\n\nCode Example:\n\nSingleParts\n\n\n/* USER CODE BEGIN PV */\n\nuint8_t rxBuffer[1];  // Buffer to store received data\n// Try changing the buffer size\n\n/* USER CODE END PV */\n\n\nvoid main(void){\n\n  /* USER CODE BEGIN 2 */\n\n  // Start interrupt-based reception\n  HAL_UART_Receive_IT(&huart3, rxBuffer, 1);\n\n  /* USER CODE END 2 */\n}\n  \n\n/* USER CODE BEGIN 4 */\n// Interrupt callback function\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {\n    if (huart-&gt;Instance == USART3) {\n        // Echo received data\n        HAL_UART_Transmit(&huart3, rxBuffer, 1, HAL_MAX_DELAY);\n\n        // Restart reception\n        HAL_UART_Receive_IT(&huart3, rxBuffer, 1);\n    }\n}\n/* USER CODE END 4 */\n\n\nUSER CODE BEGIN PV\nuint8_t rxBuffer[1];  // Buffer to store received data\n// Try changing the buffer size\nUSER CODE BEGIN 2\n// Start interrupt-based reception\nHAL_UART_Receive_IT(&huart3, rxBuffer, 1);\nUSER CODE BEGIN 4\n// Interrupt callback function\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {\n    if (huart-&gt;Instance == USART3) {\n        // Echo received data\n        HAL_UART_Transmit(&huart3, rxBuffer, 1, HAL_MAX_DELAY);\n\n        // Restart reception\n        HAL_UART_Receive_IT(&huart3, rxBuffer, 1);\n    }\n}\n\n\n\n\n\nSample IO:\n\nInput: Type “STM32” in the serial terminal.\nOutput: Each character is echoed back immediately, as data is received and transmitted using interrupts.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>UART Serial Communication using STM32 HAL</span>"
    ]
  },
  {
    "objectID": "exercises/1_uart.html#conclusion",
    "href": "exercises/1_uart.html#conclusion",
    "title": "3  UART Serial Communication using STM32 HAL",
    "section": "3.7 Conclusion:",
    "text": "3.7 Conclusion:\nIn this exercise, you explored USART serial communication on the STM Nucleo-144 F767ZI board using STM32 HAL in CubeIDE. We covered two primary communication methods: polling and interrupts.\n\nPolling was demonstrated using functions like HAL_UART_Transmit and HAL_UART_Receive, where the microcontroller continuously checks for data transmission or reception. While simple to implement, polling can block the CPU, preventing it from executing other tasks while waiting for the communication to complete.\nInterrupts, on the other hand, were introduced as a more efficient method of handling USART communication. In interrupt-based communication, the CPU can perform other tasks while waiting for data. When data is ready, an interrupt is triggered, and the appropriate callback function handles the data. This method enhances system performance and responsiveness, especially in real-time applications.\n\nBy implementing both approaches, you gained a clear understanding of how to manage serial communication effectively in embedded systems, choosing between polling and interrupts depending on system requirements. These concepts are crucial for building efficient, responsive applications in embedded environments.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>UART Serial Communication using STM32 HAL</span>"
    ]
  },
  {
    "objectID": "exercises/2_gpio.html",
    "href": "exercises/2_gpio.html",
    "title": "4  3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt",
    "section": "",
    "text": "4.1 Objective:\nBy the end of this exercise, students will:",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt</span>"
    ]
  },
  {
    "objectID": "exercises/2_gpio.html#objective",
    "href": "exercises/2_gpio.html#objective",
    "title": "4  3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt",
    "section": "",
    "text": "Implement a binary counter using three LEDs (LD1, LD2, LD3) on the STM Nucleo-144 F767ZI board.\nExplore three methods of controlling the LEDs: using HAL delay and for loops, timer interrupts, and push button interrupts.\nUnderstand the difference between using blocking delays, interrupt-driven operations, and external interrupts in embedded systems.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt</span>"
    ]
  },
  {
    "objectID": "exercises/2_gpio.html#materials",
    "href": "exercises/2_gpio.html#materials",
    "title": "4  3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt",
    "section": "4.2 Materials:",
    "text": "4.2 Materials:\n\nSTM Nucleo-144 F767ZI development board.\nOnboard user LEDs:\n\nLD1 (Green): PB0 (or PA5).\nLD2 (Blue): PB7.\nLD3 (Red): PB14.\n\nOnboard user push button (USER_BUTTON): Connected to PC13.\nCubeIDE installed on the PC.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt</span>"
    ]
  },
  {
    "objectID": "exercises/2_gpio.html#cubemx-configuration",
    "href": "exercises/2_gpio.html#cubemx-configuration",
    "title": "4  3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt",
    "section": "4.3 CubeMX Configuration:",
    "text": "4.3 CubeMX Configuration:\n\n1. GPIO Configuration for LEDs:\n\nLD1 (Green): Set PB0 (or PA5 depending on SB settings) as a GPIO Output.\nLD2 (Blue): Set PB7 as a GPIO Output.\nLD3 (Red): Set PB14 as a GPIO Output.\n\n\n\n\n\n\n\nNote\n\n\n\nIf you are using the default peripheral configuration it should be already set this way.\n\n\n\n\n2. TIM7 Configuration (For Task 2)\n\nEnable TIM7 (or any other available timer).\nConfigure the timer with a prescaler and period to generate an interrupt every 1 second.\nIn the Parameter Settings, set the following configuration.\n\nPrescaler - 48000-1\nCounter Mode - Up\nCounter Period - 2000-1\n\\[\\begin{align*}\\text{Interrupt Interval} &= \\frac{(\\text{Counter Period}+1)\\times(\\text{Prescaler}+1)}{\\text{Clock Source Frequency}}\\\\ &=\\frac{2000 \\times 48000}{96\\times10^6}=1 \\text{s}\\end{align*}\\]\n\nIn the NVIC Settings, enable the TIM7 global interrupt.\n\n\n\n\n\n\n\nNote\n\n\n\nWe are selecting TIM7 for timer as it is one of the basic timers. It uses the APB1 timer clock source as the clock source (Refer this block diagram and this section).\nThe frequency of the APB1 timer clock can be verified using the Clock Configuration tab.\n\n\n\n\n3. Button Configuration (For Task 3):\n\nSet PC13 (USER_BUTTON) as GPIO_EXTI13 in the pinout view and GPIO mode as “External Interrupt Mode with Falling edge trigger detection” and GPIO Pull-up/Pull-down to “No pull-up and no pull-down” (If default configurations of peripherals are used ith will be already enabled).\nEnable the EXTI Line [15:10] interrupt for the button in the NVIC Settings.\n\n\n\n4. Generate Code:\n\nClick Project &gt; Generate Code after setting up GPIO, Timer, and Button.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt</span>"
    ]
  },
  {
    "objectID": "exercises/2_gpio.html#explanation-of-key-functions",
    "href": "exercises/2_gpio.html#explanation-of-key-functions",
    "title": "4  3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt",
    "section": "4.4 Explanation of Key Functions:",
    "text": "4.4 Explanation of Key Functions:\n\nHAL_Delay\n\nGenerates a blocking delay, pausing program execution for the specified number of milliseconds.\nSyntax:\nHAL_Delay(milliseconds);\n\nHAL_GPIO_WritePin\n\nSets the state of a GPIO pin to HIGH or LOW, used to control the LEDs.\nSyntax:\nHAL_GPIO_WritePin(GPIOx, GPIO_Pin, PinState);\nExample:\nHAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);  // Set PB0 (LD1) to HIGH\nHAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET); // Set PB0 (LD1) to LOW\n\nHAL_TIM_Base_Start_IT\n\nStarts a timer in interrupt mode.\nSyntax:\nHAL_TIM_Base_Start_IT(&htim7);  // Start TIM7 in interrupt mode\n\nHAL_TIM_PeriodElapsedCallback\n\nThe interrupt callback function triggered when the timer reaches the specified period.\nSyntax:\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);\n\nHAL_GPIO_EXTI_Callback\n\nThe interrupt callback function triggered when the external interrupt occurs.\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt</span>"
    ]
  },
  {
    "objectID": "exercises/2_gpio.html#tasks-and-sample-io-behavior",
    "href": "exercises/2_gpio.html#tasks-and-sample-io-behavior",
    "title": "4  3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt",
    "section": "4.5 Tasks and Sample IO Behavior:",
    "text": "4.5 Tasks and Sample IO Behavior:\n\nTask 1: 3-bit LED Counter Using HAL Delay and For Loop\n\nObjective: Create a 3-bit binary counter using the LEDs, with a delay between each count, controlled by HAL_Delay() in the main loop.\nDescription:\n\nUse a for loop in the main() function to count from 0 to 7 (binary 000 to 111).\nControl the LEDs based on the binary value of the counter.\nUse HAL_Delay() to wait for 1 second between each count.\n\n\n\nCode Example\n\nSingleParts\n\n\nint main(void) {\n  /* USER CODE BEGIN WHILE */\n    while (1) {\n      // 3-bit binary counter loop (0 to 7)\n      for (uint8_t i = 0; i &lt; 8; i++) {\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, (i & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD1 (LSB)\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, (i & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD2\n        HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, (i & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET); // LD3 (MSB)\n        HAL_Delay(1000);  // 1-second delay\n      }\n    /* USER CODE END WHILE */\n\n    /* USER CODE BEGIN 3 */\n    }\n    /* USER CODE END 3 */\n}\n\n\nUSER CODE BEGIN WHILE\n// 3-bit binary counter loop (0 to 7)\nfor (uint8_t i = 0; i &lt; 8; i++) {\n  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, (i & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD1 (LSB)\n  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, (i & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD2\n  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, (i & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET); // LD3 (MSB)\n  HAL_Delay(1000);  // 1-second delay\n}\n\n\n\n\n\nSample IO:\n\nOutput: The LEDs will count in binary, with a 1-second delay between each count.\n\n000: All LEDs off.\n001: LD1 on.\n010: LD2 on.\n011: LD1 and LD2 on.\n100: LD3 on.\n101: LD1 and LD3 on.\n110: LD2 and LD3 on.\n111: All LEDs on.\n\n\n\n\n\n\nTask 2: 3-bit LED Counter Using Timer Interrupt\n\nObjective: Create a 3-bit binary counter using the LEDs, with the counter updated by a timer interrupt instead of using HAL_Delay().\nDescription:\n\nUse a timer to generate an interrupt every 1 second.\nInside the interrupt handler, increment the counter and update the LEDs to reflect the binary count.\n\n\n\nCode Example\n\nSingleParts\n\n\n/* USER CODE BEGIN PV */\nvolatile uint8_t counter = 0;  // 3-bit counter\n/* USER CODE END PV */\n\n/* USER CODE BEGIN 0 */\nvoid increment_counter(void) {\n    counter = (counter + 1) % 8;  // Increment counter and wrap around using modulo\n    // Set LED states based on counter value\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, (counter & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD1 (LSB)\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, (counter & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD2\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, (counter & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET); // LD3 (MSB)\n}\n/* USER CODE END 0 */\n\nint main(void) {\n\n  /* USER CODE BEGIN 2 */\n  // Start timer in interrupt mode\n  HAL_TIM_Base_Start_IT(&htim7);\n  /* USER CODE END 2 */\n\n}\n\n/* USER CODE BEGIN 4 */\n// Timer interrupt callback\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {\n    if (htim-&gt;Instance == TIM7) {\n        increment_counter();  // Update LED states based on counter value\n    }\n}\n/* USER CODE END 4 */\n\n\nUSER CODE BEGIN PV\nvolatile uint8_t counter = 0;  // 3-bit counter\nUSER CODE BEGIN 0\nvoid increment_counter(void) {\n    counter = (counter + 1) % 8;  // Increment counter and wrap around using modulo\n    // Set LED states based on counter value\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, (counter & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD1 (LSB)\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, (counter & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD2\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, (counter & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET); // LD3 (MSB)\n}\nUSER CODE BEGIN 2\n// Start timer in interrupt mode\nHAL_TIM_Base_Start_IT(&htim7);\nUSER CODE BEGIN 4\n// Timer interrupt callback\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {\n    if (htim-&gt;Instance == TIM7) {\n        increment_counter();  // Update LED states based on counter value\n    }\n}\n\n\n\n\n\nSample IO:\n\nOutput: The LEDs will count in binary, with a 1-second delay between each count, controlled by the timer interrupt.\n\n000: All LEDs off.\n001: LD1 on.\n010: LD2 on.\n011: LD1 and LD2 on.\n100: LD3 on.\n101: LD1 and LD3 on.\n110: LD2 and LD3 on.\n111: All LEDs on.\n\n\n\n\n\n\nTask 3: 3-bit LED Counter with Push Button Interrupt and Debounce\n\nObjective: Create a 3-bit binary counter using the LEDs, where the counter increments each time the push button is pressed, with debounce handling to ensure reliable button presses.\nDescription:\n\nConfigure the push button (USER) connected to PC13 to generate an interrupt on a button press.\nImplement a debounce mechanism to filter out false triggers due to bouncing.\nIn the interrupt handler, increment the counter and update the LEDs to reflect the new binary count.\n\n\n\nCode Example\n\nSingleParts\n\n\n/* USER CODE BEGIN PD */\n#define DEBOUNCE_DELAY_MS 50  // Debounce delay in milliseconds\n/* USER CODE END PD */\n\n/* USER CODE BEGIN PV */\nvolatile uint8_t counter = 0;  // 3-bit counter\nvolatile uint32_t last_interrupt_time = 0;  // Last interrupt time in milliseconds\n/* USER CODE END PV */\n\n/* USER CODE BEGIN 0 */\nvoid increment_counter(void) {\n    counter = (counter + 1) % 8;  // Increment counter and wrap around using modulo\n    // Set LED states based on counter value\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, (counter & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD1 (LSB)\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, (counter & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD2\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, (counter & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET); // LD3 (MSB)\n}\n/* USER CODE END 0 */\n\nint main(void) {\n    // Infinite loop\n    while (1) {\n        // No additional logic needed in the main loop, everything is handled in interrupts\n    }\n}\n\n/* USER CODE BEGIN 4 */\n// External interrupt handler\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n{\n    if(GPIO_Pin == GPIO_PIN_13  ) {\n          uint32_t current_time = HAL_GetTick();\n          if ((current_time - last_interrupt_time) &gt; DEBOUNCE_DELAY_MS) {\n              last_interrupt_time = current_time;  // Update last interrupt time\n              increment_counter();  // Update LED states based on counter value\n          }\n    }\n}\n/* USER CODE END 4 */\n\n\nUSER CODE BEGIN PD\n#define DEBOUNCE_DELAY_MS 50  // Debounce delay in milliseconds\nUSER CODE BEGIN PV\nvolatile uint8_t counter = 0;  // 3-bit counter\nvolatile uint32_t last_interrupt_time = 0;  // Last interrupt time in milliseconds\nUSER CODE BEGIN 0\nvoid increment_counter(void) {\n    counter = (counter + 1) % 8;  // Increment counter and wrap around using modulo\n    // Set LED states based on counter value\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, (counter & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD1 (LSB)\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, (counter & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);  // LD2\n    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, (counter & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET); // LD3 (MSB)\n}\nUSER CODE BEGIN 4\n// External interrupt handler\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n{\n    if(GPIO_Pin == GPIO_PIN_13  ) {\n          uint32_t current_time = HAL_GetTick();\n          if ((current_time - last_interrupt_time) &gt; DEBOUNCE_DELAY_MS) {\n              last_interrupt_time = current_time;  // Update last interrupt time\n              increment_counter();  // Update LED states based on counter value\n          }\n    }\n}\n\n\n\n\nSample IO\n\nOutput: Each press of the push button increments the counter and updates the LEDs to reflect the binary count.\n\n000: All LEDs off.\n001: LD1 on.\n010: LD2 on.\n011: LD1 and LD2 on.\n100: LD3 on.\n101: LD1 and LD3 on.\n110: LD2 and LD3 on.\n111: All LEDs on.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe debounce delay is set to 50 milliseconds in this example, but you can adjust this value depending on your specific hardware and requirements.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt</span>"
    ]
  },
  {
    "objectID": "exercises/2_gpio.html#conclusion",
    "href": "exercises/2_gpio.html#conclusion",
    "title": "4  3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt",
    "section": "4.6 Conclusion:",
    "text": "4.6 Conclusion:\nIn this exercise, you implemented a 3-bit binary counter using three different methods of LED control on the STM Nucleo-144 F767ZI board:\n\nHAL Delay and For Loop: Demonstrated a straightforward approach for controlling LEDs with blocking delays, suitable for understanding basic timing but less effective for handling concurrent tasks.\nTimer Interrupt: Showcased how to use a timer to handle periodic tasks efficiently, enabling the microcontroller to perform other operations while managing timing in the background. This method is particularly useful for tasks requiring precise timing without blocking the main execution.\nPush Button Interrupt: Introduced the concept of external interrupts triggered by user input, allowing real-time interaction with the system. This method illustrated how to handle interrupts for external events, such as button presses, and provided a way to interact with the system dynamically.\n\nThese methods provide a comprehensive understanding of managing timing and interrupts in embedded systems, helping you to appreciate the trade-offs and applications of different techniques in real-time system design.",
    "crumbs": [
      "**Using STMCubeIDE with STM HAL**",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>3-bit LED Counter Using HAL Delay, Timer Interrupts, and Button Interrupt</span>"
    ]
  },
  {
    "objectID": "getting_started/arduino_ide_with_stm32duino.html",
    "href": "getting_started/arduino_ide_with_stm32duino.html",
    "title": "5  Arduino IDE: Getting Started and How-tos",
    "section": "",
    "text": "5.1 Getting Started Guides",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Arduino IDE: Getting Started and How-tos</span>"
    ]
  },
  {
    "objectID": "getting_started/arduino_ide_with_stm32duino.html#getting-started-guides",
    "href": "getting_started/arduino_ide_with_stm32duino.html#getting-started-guides",
    "title": "5  Arduino IDE: Getting Started and How-tos",
    "section": "",
    "text": "Getting Started with Arduino IDE 2 - For installation and getting to know Arduino IDE v2.\nGetting Started with stm32duino - Wiki page for how to setup Arduino IDE for stm boards.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Arduino IDE: Getting Started and How-tos</span>"
    ]
  },
  {
    "objectID": "exercises/3_arduino_gpio.html",
    "href": "exercises/3_arduino_gpio.html",
    "title": "6  GPIO using STM32Duino",
    "section": "",
    "text": "6.1 Objectives",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>GPIO using STM32Duino</span>"
    ]
  },
  {
    "objectID": "exercises/3_arduino_gpio.html#objectives",
    "href": "exercises/3_arduino_gpio.html#objectives",
    "title": "6  GPIO using STM32Duino",
    "section": "",
    "text": "Understand and experiment with GPIO Digital Output, GPIO Digital Input, and GPIO Analog Input/Output on the STM32 Nucleo-144 F767ZI board using STM32Duino.\nLearn to use basic example sketches in Arduino IDE for controlling LEDs and reading inputs.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>GPIO using STM32Duino</span>"
    ]
  },
  {
    "objectID": "exercises/3_arduino_gpio.html#materials",
    "href": "exercises/3_arduino_gpio.html#materials",
    "title": "6  GPIO using STM32Duino",
    "section": "6.2 Materials",
    "text": "6.2 Materials\n\nSTM32 Nucleo-144 F767ZI development board.\nArduino IDE with STM32Duino configured.\nJumper wires.\nPotentiometer (for analog input task).",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>GPIO using STM32Duino</span>"
    ]
  },
  {
    "objectID": "exercises/3_arduino_gpio.html#part-1-simple-blink-gpio-digital-output",
    "href": "exercises/3_arduino_gpio.html#part-1-simple-blink-gpio-digital-output",
    "title": "6  GPIO using STM32Duino",
    "section": "6.3 Part 1: Simple Blink (GPIO Digital Output)",
    "text": "6.3 Part 1: Simple Blink (GPIO Digital Output)\n\nSteps\n\nIn Arduino IDE, go to File -&gt; Examples -&gt; 01.Basics -&gt; Blink. A new sketch will open.\nEnsure that Nucleo-144 is selected as the board. If it is not selected, choose it from the dropdown menu.\nThe code will reference LED_BUILTIN, which corresponds to the built-in LED on PB0 (LD1) on the Nucleo-F767ZI board.\nUpload the sketch to the STM32 Nucleo-144 board.\n\n\n\n\n\n\n\nImportant\n\n\n\nEnsure that the Board part number is set as Nucleo-F767ZI from the Tools menu before uploading.\n\n\n\n\nExpected Output\n\nThe built-in LED on PB0 will blink on and off with a 1-second delay.\n\n\n\nTasks\n\nModify the sketch to make all built-in LEDs (on PB0, PB7, and PB14) blink.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>GPIO using STM32Duino</span>"
    ]
  },
  {
    "objectID": "exercises/3_arduino_gpio.html#part-2-debounce-gpio-digital-input",
    "href": "exercises/3_arduino_gpio.html#part-2-debounce-gpio-digital-input",
    "title": "6  GPIO using STM32Duino",
    "section": "6.4 Part 2: Debounce (GPIO Digital Input)",
    "text": "6.4 Part 2: Debounce (GPIO Digital Input)\n\nSteps\n\nIn Arduino IDE, go to File -&gt; Examples -&gt; 02.Digital -&gt; Debounce. A new sketch will open.\nEnsure the board is correctly selected (Nucleo-144).\nSet btnPin to PC13 (the onboard button).\nSet ledPin to one of the built-in LEDs (e.g., PB0).\nUpload the sketch to the STM32 board.\n\n\n\nExpected Output\n\nThe LED will toggle between ON and OFF each time the button is pressed, with debounce logic to filter out noise from the button.\n\n\n\nTasks\n\nModify the sketch so that each button press cycles through turning PB0, PB7, and PB14 on and off in sequence (cycling the built-in LEDs).",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>GPIO using STM32Duino</span>"
    ]
  },
  {
    "objectID": "exercises/3_arduino_gpio.html#part-3-fading-gpio-analog-output",
    "href": "exercises/3_arduino_gpio.html#part-3-fading-gpio-analog-output",
    "title": "6  GPIO using STM32Duino",
    "section": "6.5 Part 3: Fading (GPIO Analog Output)",
    "text": "6.5 Part 3: Fading (GPIO Analog Output)\n\nSteps\n\nIn Arduino IDE, go to File -&gt; Examples -&gt; 03.Analog -&gt; Fading. A new sketch will open.\nUse PB0 for the built-in LED (LED_BUILTIN).\nUpload the sketch to the STM32 board.\n\n\n\nExpected Output\n\nThe built-in LED will gradually fade in and fade out.\n\n\n\nTask\n\nModify the code to alternately fade PB0 and PB7 so that one fades in while the other fades out, and vice versa.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>GPIO using STM32Duino</span>"
    ]
  },
  {
    "objectID": "exercises/3_arduino_gpio.html#part-4-calibration-gpio-analog-input",
    "href": "exercises/3_arduino_gpio.html#part-4-calibration-gpio-analog-input",
    "title": "6  GPIO using STM32Duino",
    "section": "6.6 Part 4: Calibration (GPIO Analog Input)",
    "text": "6.6 Part 4: Calibration (GPIO Analog Input)\n\nSteps\n\nIn Arduino IDE, go to File -&gt; Examples -&gt; 03.Analog -&gt; Calibration. A new sketch will open.\nConnect a potentiometer to A0 for analog input.\nUse PB0 for the LED output.\nUse PB7 to indicate calibration period.\nThis sketch calibrates the sensor (potentiometer) over the first 5 seconds to detect its minimum and maximum values, then maps the sensor readings to adjust the brightness of the LED on PB0.\nChange the calibration time to 10 seconds and try turning the potentiometer knob to both extends as possible.\nUpload the sketch to the STM32 board.\n\n\n\nCode Example (Modified from the calibration example)\nconst int sensorPin = A0;  // pin that the sensor is attached to\nconst int ledPin = PB0;      // pin that the LED is attached to\nconst int indicatorLed = PB7;// pin to indicate the calibration period\n// variables:\nint sensorValue = 0;   // the sensor value\nint sensorMin = 1023;  // minimum sensor value\nint sensorMax = 0;     // maximum sensor value\n\n\nvoid setup() {\n  Serial.begin(115200);\n  // turn on LED to signal the start of the calibration period:\n  pinMode(indicatorLed, OUTPUT);\n  digitalWrite(indicatorLed, HIGH);\n\n  // calibrate during the first 10 seconds\n  while (millis() &lt; 10000) {\n    sensorValue = analogRead(sensorPin);\n\n    // record the maximum sensor value\n    if (sensorValue &gt; sensorMax) {\n      sensorMax = sensorValue;\n    }\n\n    // record the minimum sensor value\n    if (sensorValue &lt; sensorMin) {\n      sensorMin = sensorValue;\n    }\n    Serial.print(\"sensorMin:\");\n    Serial.print(sensorMin);\n    Serial.print(',');\n    Serial.print(\"sensorMax:\");\n    Serial.print(sensorMax);\n    Serial.print(',');\n    Serial.print(\"sensorValue:\");\n    Serial.println(sensorValue);\n  }  \n  Serial.println(\"Calibration Done.\");\n  // signal the end of the calibration period\n  digitalWrite(indicatorLed, LOW);\n}\n\nvoid loop() {\n  // read the sensor:\n  sensorValue = analogRead(sensorPin);\n\n  // in case the sensor value is outside the range seen during calibration\n  sensorValue = constrain(sensorValue, sensorMin, sensorMax);\n\n  // apply the calibration to the sensor reading\n  sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255);\n\n  // fade the LED using the calibrated value:\n  analogWrite(ledPin, sensorValue);\n}\n\n\nExpected Output\n\nDuring the first 10 seconds, the sensor will calibrate its minimum and maximum values based on the potentiometer input.\nAfter calibration, the LED brightness will adjust based on the potentiometer’s position, with the sensor values mapped between 0 and 255 to control the PWM output on P0.\n\n\n\nTasks\n\nTry modifying the code to calibrate until the user button is presses instead of using a fixed time window.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>GPIO using STM32Duino</span>"
    ]
  },
  {
    "objectID": "exercises/3_arduino_gpio.html#conclusion",
    "href": "exercises/3_arduino_gpio.html#conclusion",
    "title": "6  GPIO using STM32Duino",
    "section": "6.7 Conclusion",
    "text": "6.7 Conclusion\nThis exercise introduces basic GPIO operations using STM32Duino on the STM32 Nucleo-144 F767ZI board. Students learned how to:\n\nControl LEDs using digital output (Simple Blink).\nHandle button presses using digital input with debouncing (Debounce).\nCreate fading effects with analog output (Fading).\nRead and map analog input data from a potentiometer to control the brightness of an LED (Calibration).\n\nThese examples serve as foundational tasks to deepen the understanding of GPIO handling in embedded systems.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>GPIO using STM32Duino</span>"
    ]
  },
  {
    "objectID": "exercises/4_ultrasonic_sensor.html",
    "href": "exercises/4_ultrasonic_sensor.html",
    "title": "7  Ultrasonic sensor Distance Measurement - HC-SR04",
    "section": "",
    "text": "7.1 Objective\nBy the end of this exercise, students will - Interface an HC-SR04 ultrasonic sensor with the STM32 Nucleo-144 F767ZI using STM32Duino. - Take multiple distance measurements and calculate the average. - Display the averaged distance using the serial monitor. - Control and LED with the measured distance.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Ultrasonic sensor Distance Measurement - HC-SR04</span>"
    ]
  },
  {
    "objectID": "exercises/4_ultrasonic_sensor.html#materials",
    "href": "exercises/4_ultrasonic_sensor.html#materials",
    "title": "7  Ultrasonic sensor Distance Measurement - HC-SR04",
    "section": "7.2 Materials",
    "text": "7.2 Materials\n\nSTM Nucleo-144 F767ZI development board.\nUltrasonic Sensor (HC-SR04).\nJumper wires for connections.\nSTM32Duino environment set up in Arduino IDE (with STM32 core installed).",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Ultrasonic sensor Distance Measurement - HC-SR04</span>"
    ]
  },
  {
    "objectID": "exercises/4_ultrasonic_sensor.html#hc-sr04-sensor",
    "href": "exercises/4_ultrasonic_sensor.html#hc-sr04-sensor",
    "title": "7  Ultrasonic sensor Distance Measurement - HC-SR04",
    "section": "7.3 HC-SR04 Sensor",
    "text": "7.3 HC-SR04 Sensor\n\nVCC: 5V power.\nGND: Ground.\nTrig: Trigger pin (to send out the ultrasonic pulse).\nEcho: Echo pin (to receive the reflected pulse).",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Ultrasonic sensor Distance Measurement - HC-SR04</span>"
    ]
  },
  {
    "objectID": "exercises/4_ultrasonic_sensor.html#wiring-connections",
    "href": "exercises/4_ultrasonic_sensor.html#wiring-connections",
    "title": "7  Ultrasonic sensor Distance Measurement - HC-SR04",
    "section": "7.4 Wiring Connections",
    "text": "7.4 Wiring Connections\n\nVCC -&gt; 5V pin on STM32.\nGND -&gt; GND pin on STM32.\nTrig -&gt; D12 or any available digital GPIO pin (using in the Arduino Compatible zio connector)\nEcho -&gt; D13 or any available digital GPIO pin.\n\n\n\n\n\n\n\nTip\n\n\n\nWhile using Stm32duino with Arduino in Arduino compatible board, the Arduino pin conventions can also be used in the program. Eg. A0 for anolog pin, 12 for digital pin.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Ultrasonic sensor Distance Measurement - HC-SR04</span>"
    ]
  },
  {
    "objectID": "exercises/4_ultrasonic_sensor.html#explanation-of-key-functions",
    "href": "exercises/4_ultrasonic_sensor.html#explanation-of-key-functions",
    "title": "7  Ultrasonic sensor Distance Measurement - HC-SR04",
    "section": "7.5 Explanation of Key Functions",
    "text": "7.5 Explanation of Key Functions\n\ndigitalWrite(pin, HIGH/LOW): Sends a HIGH or LOW signal to the pin to activate or deactivate the trigger pin.\npulseIn(pin, HIGH): Measures the time for the echo pin to go HIGH, which is proportional to the distance.\nSerial communication functions: To print the results on the Serial Monitor.\n\nSerial.begin(baud_rate) - Should be initialized in the setup to start the serial communication. The baud rate can be typically set to 9600 or 115200.\nSerial.print - Prints a value in the serial monitor.\nSerial.println - Same as print but also prints a newline character at the end.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Ultrasonic sensor Distance Measurement - HC-SR04</span>"
    ]
  },
  {
    "objectID": "exercises/4_ultrasonic_sensor.html#tasks-and-sample-io-behavior",
    "href": "exercises/4_ultrasonic_sensor.html#tasks-and-sample-io-behavior",
    "title": "7  Ultrasonic sensor Distance Measurement - HC-SR04",
    "section": "7.6 Tasks and Sample IO Behavior",
    "text": "7.6 Tasks and Sample IO Behavior\n\nTask 1: Interface HC-SR04 with STM32 and Measure Distance\n\nObjective: Write code to interface the HC-SR04 with the STM32 Nucleo-144 F767ZI, measure the distance, and print the result on the Serial Monitor.\n\n\nExample Code\n#define TRIG_PIN 12  // Trigger pin\n#define ECHO_PIN 13  // Echo pin\n\n\nvoid setup() {\n  Serial.begin(9600);         // Initialize serial communication\n  pinMode(TRIG_PIN, OUTPUT);  // Set the trigger pin as an output\n  pinMode(ECHO_PIN, INPUT);   // Set the echo pin as an input\n}\n\nvoid loop() {\n  float distance = measureDistance();\n  // Print the average distance to the Serial Monitor\n  Serial.print(\"Distance: \");\n  Serial.print(distance);\n  Serial.println(\" cm\");\n\n  delay(1000);  // Delay before taking another set of measurements\n}\n\nfloat measureDistance() {\n  long duration;\n  float distance;\n  // Clear the trigger pin\n  digitalWrite(TRIG_PIN, LOW);\n  delayMicroseconds(2);\n\n  // Send a 10µs pulse to trigger the sensor\n  digitalWrite(TRIG_PIN, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(TRIG_PIN, LOW);\n\n  // Measure the time of the echo pulse\n  duration = pulseIn(ECHO_PIN, HIGH);\n\n  // Calculate the distance (speed of sound is 34300 cm/s)\n  distance = (duration * 0.0343) / 2;\n  return distance;\n}\n\n\nSample Output on Serial Monitor\nDistance: 25.34 cm\nDistance: 26.21 cm\nDistance: 25.78 cm\n\n\n\nTask 2: Take Multiple Measurements and Calculate the Average\n\nObjective: Modify the program to take 10 distance measurements and calculate the average to improve accuracy. Display the averaged distance on the Serial Monitor.\n\n\nExample Code(modify the code from above task)\n\n/* pin configurations*/\n\n/* setup goes here*/\n\nvoid loop() {\n  // Print the average distance to the Serial Monitor\n  Serial.print(\"Distance: \");\n  Serial.print(measureDistanceSmooth(10));  // Averaging 10 measurements\n  Serial.println(\" cm\");\n\n  delay(1000);  // Delay before taking another set of measurements\n}\n\n/* Measure Distance Function */\n\nfloat measureDistanceSmooth(int numMeasurements) {\n  float totalDistance = 0.0;\n\n  // Take multiple measurements\n  for (int i = 0; i &lt; numMeasurements; i++) {\n    // Add to the total distance for averaging\n    totalDistance += measureDistance();\n    delay(5);  // Small delay between measurements\n  }\n\n  // return the average distance\n  return totalDistance / numMeasurements;\n}\n\n\nSample Output on Serial Monitor\nDistance: 25.34 cm\nDistance: 25.35 cm\nDistance: 25.33 cm\n\n\n\nTask 3: Calibrate Ultrasonic Sensor and Fade LED with Sensor Measurement\n\nObjective\n\nCalibrate the HC-SR04 sensor by recording minimum and maximum distance readings.\nPerform calibration until a button press is detected using an interrupt.\nControl the brightness of the built-in LED on PA0 (using PWM to fade) based on the measured distance.\n\n\n\n\nSteps\n\nCalibration Phase:\n\nStart taking distance readings and continuously update the minimum and maximum values.\nThe calibration phase continues until the button is pressed, triggering an interrupt.\n\nLED Brightness Control:\n\nAfter calibration, the measured distance is used to control the brightness of the LED on PA0 using PWM.\nThe brightness will vary proportionally between the minimum and maximum measured distances.\n\n\n\n\nCode Example (Include measuring functions from the above task.)\n#define TRIG_PIN 12  // Trigger pin\n#define ECHO_PIN 13  // Echo pin\n#define LED_PIN PB0   // Inbuilt-LED Pin\n#define BUTTON_PIN PC13 // Inbuilt Button pin\n\n\nvolatile bool calibrationComplete = false;\nfloat minDistance = 1000;  // Large initial value for calibration\nfloat maxDistance = 0;     // Small initial value for calibration\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(TRIG_PIN, OUTPUT);\n  pinMode(ECHO_PIN, INPUT);\n  pinMode(LED_PIN, OUTPUT);\n  pinMode(BUTTON_PIN, INPUT);\n\n  // Attach interrupt for the button press\n  attachInterrupt(digitalPinToInterrupt(BUTTON_PIN), completeCalibration, FALLING);\n\n  // Set up PWM for LED pin\n  analogWriteResolution(8);  // 8-bit resolution (0-255)\n}\n\n\nvoid loop() {\n  if (!calibrationComplete) {\n    float distance = measureDistance();\n\n    // Update min/max distances for calibration\n    if (distance &lt; minDistance) minDistance = distance;\n    if (distance &gt; maxDistance) maxDistance = distance;\n\n    Serial.print(\"Calibrating... Min: \");\n    Serial.print(minDistance);\n    Serial.print(\" cm, Max: \");\n    Serial.println(maxDistance);\n\n    delay(500);  // Slow down calibration readings\n  } else {\n    // After calibration, use distance to control LED brightness\n    float currentDistance = measureDistanceSmooth(10);\n    int brightness = map(currentDistance, minDistance, maxDistance, 0, 255);  // Map distance to brightness\n    brightness = constrain(brightness, 0, 255);  // Ensure the value stays within 0-255 range\n\n    analogWrite(LED_PIN, brightness);  // Set LED brightness\n\n    Serial.print(\"Distance(cm):\");\n    Serial.print(currentDistance);\n    Serial.print(\",LED Brightness:\");\n    Serial.println(brightness);\n\n    delay(200);  // Slow down the readings\n  }\n}\n\n/* Measuring functions*/\n\n// Button interrupt handler to stop calibration\nvoid completeCalibration() {\n  calibrationComplete = true;\n  Serial.println(\"Calibration complete.\");\n}\n\n\nSample Output on Serial Monitor\nCalibrating... Min: 10.34 cm, Max: 58.21 cm\nCalibrating... Min: 9.67 cm, Max: 61.52 cm\nCalibration complete.\nDistance(cm):35.42 cm,LED Brightness:128\nDistance(cm):20.30 cm,LED Brightness:64\n\n\n\n\n\n\nTip\n\n\n\nYou can use serial plotter to view graphs of the serial output. You can use serial plotter in two ways. 1. Just printing comma seperated values in the serial monitor. 2. Using the format {label 1}:{value 1}, {label 2}:{value 2} which will show the labels in the serial plotter.\n\n\n\n\n\nConclusion\n\nInterfacing an Ultrasonic Sensor: The HC-SR04 ultrasonic sensor was interfaced with the STM32 Nucleo-144 F767ZI using the STM32Duino platform.\nSerial Communication: The measured results were displayed on the Serial Monitor using the Serial.print() function, emphasizing the role of serial communication in embedded systems.\nTiming and Control: Concepts such as trigger pulses and delay functions were applied to manage sensor timing and ensure reliable operation.\nButton Interrupts: This task demonstrated how to use button interrupts to stop a calibration phase.\nPWM Control: The PWM output on PA0 was used to control LED brightness based on the distance measured by the ultrasonic sensor.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Ultrasonic sensor Distance Measurement - HC-SR04</span>"
    ]
  },
  {
    "objectID": "exercises/5_temperature_sensor_i2c.html",
    "href": "exercises/5_temperature_sensor_i2c.html",
    "title": "8  Temperature measurement using I2C - MCP9808",
    "section": "",
    "text": "8.1 Objective\nBy the end of this exercise, students will: - Interface the MCP9808 temperature sensor with the STM32 Nucleo-144 F767ZI board using I2C communication. - Measure temperature in both Celsius and Fahrenheit using two methods: 1. Sensor-specific library (Seeed_MCP9808). 2. Direct I2C communication via Wire.h library.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Temperature measurement using I2C - MCP9808</span>"
    ]
  },
  {
    "objectID": "exercises/5_temperature_sensor_i2c.html#objective",
    "href": "exercises/5_temperature_sensor_i2c.html#objective",
    "title": "8  Temperature measurement using I2C - MCP9808",
    "section": "",
    "text": "Note\n\n\n\nThe Seeed_MCP9808 library can be downloaded as zip from here. You can add this library to the arduino sketch by Sketch-&gt;Include Library-&gt;Add .zip Library.\n\n\n\n\n\n\n\n\nNote",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Temperature measurement using I2C - MCP9808</span>"
    ]
  },
  {
    "objectID": "exercises/5_temperature_sensor_i2c.html#materials",
    "href": "exercises/5_temperature_sensor_i2c.html#materials",
    "title": "8  Temperature measurement using I2C - MCP9808",
    "section": "8.2 Materials",
    "text": "8.2 Materials\n\nSTM Nucleo-144 F767ZI development board.\nMCP9808 temperature sensor - Datasheet.\nJumper wires.\nCubeIDE or Arduino IDE with STM32Duino.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Temperature measurement using I2C - MCP9808</span>"
    ]
  },
  {
    "objectID": "exercises/5_temperature_sensor_i2c.html#wiring-connections",
    "href": "exercises/5_temperature_sensor_i2c.html#wiring-connections",
    "title": "8  Temperature measurement using I2C - MCP9808",
    "section": "8.3 Wiring Connections",
    "text": "8.3 Wiring Connections\n\n\n\nMCP9808 Pin\nNucleo-144 Pin\n\n\n\n\nVCC\n3.3V\n\n\nGND\nGND\n\n\nSDA\nD14/SDA\n\n\nSCL\nD15/SCL",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Temperature measurement using I2C - MCP9808</span>"
    ]
  },
  {
    "objectID": "exercises/5_temperature_sensor_i2c.html#task-1-using-seeed_mcp9808-library",
    "href": "exercises/5_temperature_sensor_i2c.html#task-1-using-seeed_mcp9808-library",
    "title": "8  Temperature measurement using I2C - MCP9808",
    "section": "8.4 Task 1: Using Seeed_MCP9808 Library",
    "text": "8.4 Task 1: Using Seeed_MCP9808 Library\n\nDescription\nIn this task, the MCP9808 sensor is interfaced using the Seeed_MCP9808 library. The library abstracts the I2C communication, to easily read the temperature in Celsius and convert it to Fahrenheit.\n\n\nCode\n#include \"Seeed_MCP9808.h\"\n\nMCP9808 sensor;\n\nvoid setup() {\n  Serial.begin(9600);\n  if (sensor.init()) {\n    Serial.println(\"Sensor init failed.\");\n    return;\n  }\n  Serial.println(\"Sensor init success.\");\n}\n\nvoid loop() {\n  float celsius = 0;\n  sensor.get_temp(&celsius);\n\n  float fahrenheit = celsius * 9 / 5 + 32;\n\n  Serial.print(\"Temperature: \");\n  Serial.print(celsius);\n  Serial.print(\"C/\");\n  Serial.print(fahrenheit);\n  Serial.println(\"F\");\n  delay(1000);\n}\n\n\nKey Steps\n\nInitialize the MCP9808 sensor using the Seeed_MCP9808 library.\nRead the temperature in Celsius, convert it to Fahrenheit, and display both on the serial monitor.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Temperature measurement using I2C - MCP9808</span>"
    ]
  },
  {
    "objectID": "exercises/5_temperature_sensor_i2c.html#task-2-using-wire.h-library-for-direct-i2c-communication",
    "href": "exercises/5_temperature_sensor_i2c.html#task-2-using-wire.h-library-for-direct-i2c-communication",
    "title": "8  Temperature measurement using I2C - MCP9808",
    "section": "8.5 Task 2: Using Wire.h Library for Direct I2C Communication",
    "text": "8.5 Task 2: Using Wire.h Library for Direct I2C Communication\n\nDescription\nThis task involves using direct I2C communication with the MCP9808 sensor via the Wire.h library. Students will manually configure and communicate with the sensor to read temperature data, without relying on a sensor-specific library.\n\n\nCode\n#include &lt;Wire.h&gt;\n\n#define MCP9808_I2C_ADDRESS 0x18  // Default I2C address for MCP9808\n#define AMBIENT_TEMP_REG 0x05     // Ambient temperature register\n#define RESOLUTION_REG 0x08       // Resolution register\n#define RESOLUTION_0_0625_DEGREE 0x03 // Highest resolution\n\nvoid setup() {\n  Wire.begin();\n  Serial.begin(9600);\n\n  // Initialize the sensor\n  if (initSensor()) {\n    Serial.println(\"Sensor init failed.\");\n  } else {\n    Serial.println(\"Sensor init success.\");\n  }\n}\n\nvoid loop() {\n  float celsius = readTemperature();\n  float fahrenheit = celsius * 9.0 / 5.0 + 32;\n\n  Serial.print(\"Temperature: \");\n  Serial.print(celsius);\n  Serial.print(\" C / \");\n  Serial.print(fahrenheit);\n  Serial.println(\" F\");\n\n  delay(1000);  // Wait 1 second before reading the temperature again\n}\n\n// Function to initialize the sensor\nbool initSensor() {\n  Wire.beginTransmission(MCP9808_I2C_ADDRESS);\n  Wire.write(RESOLUTION_REG);           // Set the resolution register\n  Wire.write(RESOLUTION_0_0625_DEGREE); // Set highest resolution (0.0625°C)\n  return (Wire.endTransmission() != 0); // Check for I2C transmission success\n}\n\n// Function to read temperature from the MCP9808 sensor\nfloat readTemperature() {\n  Wire.beginTransmission(MCP9808_I2C_ADDRESS);\n  Wire.write(AMBIENT_TEMP_REG);  // Set pointer to the temperature register\n  Wire.endTransmission();\n\n  Wire.requestFrom(MCP9808_I2C_ADDRESS, 2);  // Request 2 bytes from sensor\n\n  if (Wire.available() &lt; 2) {\n    return NAN;  // If data not available, return not-a-number (NAN)\n  }\n\n  // Read the 2 bytes of temperature data\n  uint8_t msb = Wire.read();\n  uint8_t lsb = Wire.read();\n\n  // Combine the two bytes into a 16-bit unsigned integer\n  uint16_t rawTemp = ((uint16_t)msb &lt;&lt; 8) | lsb;\n\n  // Mask out the sign bit (bit 12) and calculate the temperature\n  rawTemp &= 0x0FFF;\n  float temp = rawTemp * 0.0625;  // Each increment represents 0.0625°C\n\n  // If the sign bit is set, the temperature is negative\n  if (msb & 0x10) {\n    temp -= 256;\n  }\n\n  return temp;\n}\n\n\n\n\n\n\nTip\n\n\n\nBonus Task: Modify the code from task 2, to read the temperature at a different resolution.(Refer Datasheet for the Resolution Register values.)",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Temperature measurement using I2C - MCP9808</span>"
    ]
  },
  {
    "objectID": "exercises/5_temperature_sensor_i2c.html#conclusion",
    "href": "exercises/5_temperature_sensor_i2c.html#conclusion",
    "title": "8  Temperature measurement using I2C - MCP9808",
    "section": "8.6 Conclusion",
    "text": "8.6 Conclusion\n\nThe MCP9808 sensor was interfaced with the STM32 Nucleo-144 board using I2C communication.\nTwo methods of communication were explored:\n\nA sensor-specific library (Seeed_MCP9808) for easy implementation.\nDirect I2C communication via the Wire.h library to give a more in-depth understanding of sensor interfacing.\n\nBoth methods demonstrated how to read and process temperature data from the MCP9808 sensor.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Temperature measurement using I2C - MCP9808</span>"
    ]
  },
  {
    "objectID": "exercises/6_accelgyro_i2c.html",
    "href": "exercises/6_accelgyro_i2c.html",
    "title": "9  Accelerometer and Gyroscope - MPU-6050",
    "section": "",
    "text": "This exercise introduces interfacing the MPU-6050 accelerometer and gyroscope sensor with the STM32 Nucleo-144 board using the MPU6050 library by Electronic Cats. The sensor readings (acceleration and gyroscope values) will be displayed and averaged over 20 samples.\n\n\n\n\n\n\nNote\n\n\n\nThe MPU6050 library by Electronic Cats can be installed using library manager in the Aruduino IDE.\n\n\n\nObjective:\n\nInterface the MPU-6050 sensor with the STM32 Nucleo-144 board via I2C.\nRead raw acceleration and gyroscope data from the sensor.\nAverage the readings over 20 samples to smooth out the data.\n\n\n\nMaterials:\n\nSTM Nucleo-144 F767ZI development board.\nMPU-6050 sensor.\nJumper wires.\nCubeIDE or Arduino IDE with STM32Duino.\n\n\n\nWiring Connections:\n\n\n\nMPU-6050 Pin\nNucleo-144 Pin\n\n\n\n\nVCC\n3.3V\n\n\nGND\nGND\n\n\nSDA\nSDA\n\n\nSCL\nSCL\n\n\n\n\n\n\nTask 1: Basic Reading of Accelerometer and Gyroscope Data\n\nDescription:\nIn this task, the MPU-6050 sensor will be initialized, and raw acceleration and gyroscope values will be read. The results will be displayed using the serial plotter.\n\n\nCode:\n#include \"Wire.h\"\n#include \"MPU6050.h\"\n\n// class default I2C address is 0x68\nMPU6050 accelgyro;\n\nint16_t ax, ay, az;\nint16_t gx, gy, gz;\n\nvoid setup() {\n  // join I2C bus\n  Wire.begin();\n\n  Serial.begin(115200);\n\n  // initialize device\n  Serial.println(\"Initializing I2C devices...\");\n  accelgyro.initialize();\n  Serial.println(\"Testing device connections...\");\n  Serial.println(accelgyro.testConnection() ? \"MPU6050 connection successful\" : \"MPU6050 connection failed\");\n}\n\nvoid loop() {\n  // read raw accel/gyro measurements from device\n  accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);\n\n  // display comma-separated accel/gyro x/y/z values for serial plotter\n  Serial.print(\"ax:\");\n  Serial.print(ax);\n  Serial.print(\",\");\n  Serial.print(\"ay:\");\n  Serial.print(ay);\n  Serial.print(\",\");\n  Serial.print(\"az:\");\n  Serial.print(az);\n  Serial.print(\",\");\n  Serial.print(\"gx:\");\n  Serial.print(gx);\n  Serial.print(\",\");\n  Serial.print(\"gy:\");\n  Serial.print(gy);\n  Serial.print(\",\");\n  Serial.print(\"gz:\");\n  Serial.println(gz);\n}\n\n\nKey Steps:\n\nInitialize the MPU-6050 sensor and check for a successful connection.\nRead and display the raw accelerometer and gyroscope data.\nUse the serial plotter to visualize the x, y, and z axis values.\n\n\n\n\n\nTask 2: Averaging the Readings Over 20 Samples\n\nDescription:\nIn this task, the raw accelerometer and gyroscope data will be averaged over 20 readings to smooth out any noise in the measurements.\n\n\nCode:\n#include \"Wire.h\"\n#include \"MPU6050.h\"\n\nMPU6050 accelgyro;\n\nint16_t ax, ay, az;\nint16_t gx, gy, gz;\n\n\nvoid setup() {\n  Wire.begin();\n  Serial.begin(115200);\n\n  // initialize device\n  Serial.println(\"Initializing I2C devices...\");\n  accelgyro.initialize();\n  Serial.println(\"Testing device connections...\");\n  Serial.println(accelgyro.testConnection() ? \"MPU6050 connection successful\" : \"MPU6050 connection failed\");\n}\n\nvoid loop() {\n\n  getMotion6Smooth(&ax, &ay, &az, &gx, &gy, &gz, 20);\n  // Display averaged values\n  Serial.print(\"ax:\");\n  Serial.print(ax);\n  Serial.print(\",\");\n  Serial.print(\"ay:\");\n  Serial.print(ay);\n  Serial.print(\",\");\n  Serial.print(\"az:\");\n  Serial.print(az);\n  Serial.print(\",\");\n  Serial.print(\"gx:\");\n  Serial.print(gx);\n  Serial.print(\",\");\n  Serial.print(\"gy:\");\n  Serial.print(gy);\n  Serial.print(\",\");\n  Serial.print(\"gz:\");\n  Serial.println(gz);\n  delay(10);\n\n}\n\nvoid getMotion6Smooth(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz, int nSamples) {\n  // Initialize totals\n  long axTotal = 0, ayTotal = 0, azTotal = 0;\n  long gxTotal = 0, gyTotal = 0, gzTotal = 0;\n\n  // Collect 20 samples\n  for (int i = 0; i &lt; nSamples; i++) {\n    accelgyro.getMotion6(ax, ay, az, gx, gy, gz);\n    axTotal += *ax;\n    ayTotal += *ay;\n    azTotal += *az;\n    gxTotal += *gx;\n    gyTotal += *gy;\n    gzTotal += *gz;\n  }\n\n  // Calculate average\n  *ax = axTotal / nSamples;\n  *ay = ayTotal / nSamples;\n  *az = azTotal / nSamples;\n  *gx = gxTotal / nSamples;\n  *gy = gyTotal / nSamples;\n  *gz = gzTotal / nSamples;\n}\n\n\nKey Steps:\n\nCollect 20 samples of accelerometer and gyroscope readings.\nCalculate the average of each axis (x, y, z) for both accelerometer and gyroscope.\nDisplay the averaged readings to reduce noise and obtain more stable values.\n\n\n\n\n\nConclusion:\n\nThe MPU-6050 sensor was interfaced with the STM32 Nucleo-144 board using I2C communication using library.\nRaw accelerometer and gyroscope readings were captured and displayed.\nThe readings from the accelerometer and gyroscope was visualized using serial plotter.\nAveraging over 20 samples was used to smooth the sensor data and reduce noise.",
    "crumbs": [
      "**Using Arduino IDE with stm32duino**",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>**Accelerometer and Gyroscope - MPU-6050**</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "10  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Summary</span>"
    ]
  }
]